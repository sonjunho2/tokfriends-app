diff --git a/node_modules/expo-in-app-purchases/android/src/main/java/expo/modules/inapppurchases/InAppPurchasesModule.java b/node_modules/expo-in-app-purchases/android/src/main/java/expo/modules/inapppurchases/InAppPurchasesModule.java
deleted file mode 100644
index f763c17..0000000
--- a/node_modules/expo-in-app-purchases/android/src/main/java/expo/modules/inapppurchases/InAppPurchasesModule.java
+++ /dev/null
@@ -1,98 +0,0 @@
-package expo.modules.inapppurchases;
-
-import java.util.List;
-
-import android.content.Context;
-import android.app.Activity;
-import android.util.Log;
-
-import expo.modules.core.ExportedModule;
-import expo.modules.core.ModuleRegistry;
-import expo.modules.core.Promise;
-import expo.modules.core.arguments.ReadableArguments;
-import expo.modules.core.interfaces.ExpoMethod;
-import expo.modules.core.interfaces.ActivityProvider;
-import expo.modules.core.interfaces.RegistryLifecycleListener;
-import expo.modules.core.interfaces.services.EventEmitter;
-
-public class InAppPurchasesModule extends ExportedModule implements RegistryLifecycleListener {
-  private static final String TAG = InAppPurchasesModule.class.getSimpleName();
-  private static final String NAME = "ExpoInAppPurchases";
-  private final String USE_GOOGLE_PLAY_CACHE_KEY = "useGooglePlayCache";
-
-  private BillingManager mBillingManager;
-  private ModuleRegistry mModuleRegistry;
-  private EventEmitter mEventEmitter;
-
-  public InAppPurchasesModule(Context context) {
-    super(context);
-  }
-
-  @Override
-  public String getName() {
-    return NAME;
-  }
-
-  @Override
-  public void onCreate(ModuleRegistry moduleRegistry) {
-    mModuleRegistry = moduleRegistry;
-  }
-
-  @ExpoMethod
-  public void connectAsync(final Promise promise) {
-    Activity activity = getCurrentActivity();
-    if (activity == null) {
-      promise.reject("E_ACTIVITY_UNAVAILABLE", "Activity is not available");
-    }
-    mEventEmitter = mModuleRegistry.getModule(EventEmitter.class);
-    mBillingManager = new BillingManager(activity, mEventEmitter);
-    mBillingManager.startConnection(promise);
-  }
-
-  @ExpoMethod
-  public void getProductsAsync(List<String> itemList, final Promise promise) {
-    mBillingManager.queryPurchasableItems(itemList, promise);
-  }
-
-  @ExpoMethod
-  public void getPurchaseHistoryAsync(final ReadableArguments options, final Promise promise) {
-    if (options.getBoolean(USE_GOOGLE_PLAY_CACHE_KEY, true)) {
-      mBillingManager.queryPurchases(promise);
-    } else {
-      mBillingManager.queryPurchaseHistoryAsync(promise);
-    }
-  }
-
-  @ExpoMethod
-  public void purchaseItemAsync(String skuId, ReadableArguments details, final Promise promise) {
-    mBillingManager.purchaseItemAsync(skuId, details, promise);
-  }
-
-  @ExpoMethod
-  public void getBillingResponseCodeAsync(final Promise promise) {
-    promise.resolve(mBillingManager.getBillingClientResponseCode());
-  }
-
-  @ExpoMethod
-  public void finishTransactionAsync(String purchaseToken, Boolean consume, final Promise promise) {
-    if (consume != null && consume) {
-      mBillingManager.consumeAsync(purchaseToken, promise);
-    } else {
-      mBillingManager.acknowledgePurchaseAsync(purchaseToken, promise);
-    }
-  }
-
-  @ExpoMethod
-  public void disconnectAsync(final Promise promise) {
-    if (mBillingManager != null) {
-      mBillingManager.destroy();
-      mBillingManager = null;
-    }
-    promise.resolve(null);
-  }
-
-  private Activity getCurrentActivity() {
-    ActivityProvider activityProvider = mModuleRegistry.getModule(ActivityProvider.class);
-    return activityProvider != null ? activityProvider.getCurrentActivity() : null;
-  }
-}
diff --git a/node_modules/expo-in-app-purchases/android/src/main/java/expo/modules/inapppurchases/InAppPurchasesModule.kt b/node_modules/expo-in-app-purchases/android/src/main/java/expo/modules/inapppurchases/InAppPurchasesModule.kt
new file mode 100644
index 0000000..ce997cf
--- /dev/null
+++ b/node_modules/expo-in-app-purchases/android/src/main/java/expo/modules/inapppurchases/InAppPurchasesModule.kt
@@ -0,0 +1,114 @@
+package expo.modules.inapppurchases
+
+import android.app.Activity
+import expo.modules.core.arguments.ReadableArguments
+import expo.modules.core.interfaces.services.EventEmitter
+import expo.modules.kotlin.Promise
+import expo.modules.kotlin.modules.Module
+import expo.modules.kotlin.modules.ModuleDefinition
+
+private typealias KotlinPromise = Promise
+@Suppress("DEPRECATION")
+private typealias LegacyPromise = expo.modules.core.Promise
+
+class InAppPurchasesModule : Module() {
+  private var billingManager: BillingManager? = null
+  private val useGooglePlayCacheKey = "useGooglePlayCache"
+
+  override fun definition() = ModuleDefinition {
+    Name("ExpoInAppPurchases")
+
+    AsyncFunction("connectAsync") { promise: KotlinPromise ->
+      val activity = requireCurrentActivity(promise) ?: return@AsyncFunction
+      val eventEmitter = appContext.legacyModule<EventEmitter>()
+      if (eventEmitter == null) {
+        promise.reject(
+          "E_EVENT_EMITTER_UNAVAILABLE",
+          "Event emitter is not available",
+          null
+        )
+        return@AsyncFunction
+      }
+
+      billingManager?.destroy()
+      val manager = BillingManager(activity, eventEmitter)
+      billingManager = manager
+      manager.startConnection(promise.toLegacyPromise())
+    }
+
+    AsyncFunction("getProductsAsync") { productIds: List<String>, promise: KotlinPromise ->
+      withBillingManager(promise) { manager ->
+        manager.queryPurchasableItems(productIds, promise.toLegacyPromise())
+      }
+    }
+
+    AsyncFunction("getPurchaseHistoryAsync") { options: ReadableArguments?, promise: KotlinPromise ->
+      withBillingManager(promise) { manager ->
+        val useGooglePlayCache = options?.getBoolean(useGooglePlayCacheKey, true) ?: true
+        if (useGooglePlayCache) {
+          manager.queryPurchases(promise.toLegacyPromise())
+        } else {
+          manager.queryPurchaseHistoryAsync(promise.toLegacyPromise())
+        }
+      }
+    }
+
+    AsyncFunction("purchaseItemAsync") { skuId: String, details: ReadableArguments?, promise: KotlinPromise ->
+      withBillingManager(promise) { manager ->
+        manager.purchaseItemAsync(skuId, details, promise.toLegacyPromise())
+      }
+    }
+
+    AsyncFunction("getBillingResponseCodeAsync") {
+      billingManager?.getBillingClientResponseCode() ?: BillingManager.BILLING_MANAGER_NOT_INITIALIZED
+    }
+
+    AsyncFunction("finishTransactionAsync") { purchaseToken: String, consume: Boolean?, promise: KotlinPromise ->
+      withBillingManager(promise) { manager ->
+        if (consume == true) {
+          manager.consumeAsync(purchaseToken, promise.toLegacyPromise())
+        } else {
+          manager.acknowledgePurchaseAsync(purchaseToken, promise.toLegacyPromise())
+        }
+      }
+    }
+
+    AsyncFunction("disconnectAsync") { promise: KotlinPromise ->
+      billingManager?.let {
+        it.destroy()
+        billingManager = null
+      }
+      promise.resolve(null)
+    }
+
+    OnDestroy {
+      billingManager?.destroy()
+      billingManager = null
+    }
+  }
+
+  private fun requireCurrentActivity(promise: KotlinPromise): Activity? {
+    val activity = appContext.currentActivity
+    if (activity == null) {
+      promise.reject("E_ACTIVITY_UNAVAILABLE", "Activity is not available", null)
+      return null
+    }
+    return activity
+  }
+
+  private inline fun withBillingManager(promise: KotlinPromise, block: (BillingManager) -> Unit) {
+    val manager = billingManager
+    if (manager == null) {
+      promise.reject(
+        "E_BILLING_NOT_INITIALIZED",
+        "Billing is not initialized. Call connectAsync() first.",
+        null
+      )
+      return
+    }
+    block(manager)
+  }
+}
+
+@Suppress("TYPEALIAS_EXPANSION_DEPRECATION")
+private fun KotlinPromise.toLegacyPromise(): LegacyPromise {
+  val newPromise = this
+  return object : LegacyPromise {
+    override fun resolve(value: Any?) {
+      newPromise.resolve(value)
+    }
+
+    override fun reject(code: String?, message: String?, throwable: Throwable?) {
+      newPromise.reject(code ?: "unknown", message, throwable)
+    }
+  }
+}
diff --git a/node_modules/expo-in-app-purchases/android/src/main/java/expo/modules/inapppurchases/InAppPurchasesPackage.java b/node_modules/expo-in-app-purchases/android/src/main/java/expo/modules/inapppurchases/InAppPurchasesPackage.java
index 663bf07..4c2dc57 100644
--- a/node_modules/expo-in-app-purchases/android/src/main/java/expo/modules/inapppurchases/InAppPurchasesPackage.java
+++ b/node_modules/expo-in-app-purchases/android/src/main/java/expo/modules/inapppurchases/InAppPurchasesPackage.java
@@ -1,16 +1,5 @@
 package expo.modules.inapppurchases;
 
-import android.content.Context;
-
-import java.util.Collections;
-import java.util.List;
-
 import expo.modules.core.BasePackage;
-import expo.modules.core.ExportedModule;
 
-public class InAppPurchasesPackage extends BasePackage {
-  @Override
-  public List<ExportedModule> createExportedModules(Context context) {
-    return Collections.singletonList((ExportedModule) new InAppPurchasesModule(context));
-  }
-}
+public class InAppPurchasesPackage extends BasePackage {}
